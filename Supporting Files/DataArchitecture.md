# Data Architecture and Flow in ReadBuddy

This document outlines the data architecture of the ReadBuddy application, focusing on how data is structured, stored in Firebase, retrieved, and how content (including stories) is generated and displayed to the user. This analysis primarily covers the frontend application logic and excludes backend-specific implementation details.

## 1. Data Models

The application uses two sets of models: local Swift models for in-app logic and views, and Firebase-specific models for data (de)serialization with Firestore.

### 1.1. Local App Models (primarily in `Models.swift`)

These structures are used throughout the app to handle data and state.

*   **`Story`**: Represents a narrative generated by the app.
    *   `id`: `UUID`
    *   `title`: `String`
    *   `content`: `String` (Overall overview/summary of the story)
    *   `level`: `ReadingLevel` (Enum: Kid, PreTeen, Teen, University, Standard)
    *   `chapters`: `[StoryChapter]`
    *   `imageStyle`: `String?` (e.g., "ghibli", "comicBook")

*   **`StoryChapter`**: Represents a chapter within a `Story`.
    *   `id`: `UUID`
    *   `title`: `String`
    *   `content`: `String` (Text content of the chapter)
    *   `order`: `Int`
    *   `imageUrl`: `String?` (URL of the image for the chapter, typically from Firebase Storage)
    *   `localImagePath`: `String?` (Path to a locally stored image, used temporarily or for caching)
    *   `imageStyle`: `String?`

*   **`ContentBlock`**: A versatile structure for displaying various types of content (summaries, explanations, quizzes).
    *   `id`: `UUID`
    *   `type`: `BlockType` (Enum: heading, paragraph, image, quizHeading, multipleChoiceQuestion, error)
    *   `content`: `String?` (Text content, e.g., paragraph text, heading text)
    *   `url`: `String?` (URL for images)
    *   `alt`: `String?` (Accessibility text for images)
    *   `localImagePath`: `String?`
    *   `imageStyle`: `String?`
    *   `options`: `[QuizOption]?` (For multiple-choice questions)
    *   `correctAnswerID`: `String?` (ID of the correct `QuizOption`)
    *   `explanation`: `String?` (Explanation for quiz answers)

*   **`QuizOption`**: Represents an option in a multiple-choice quiz.
    *   `id`: `String`
    *   `text`: `String`

*   **`ReadingLevel`**: Enum defining different reading difficulty levels.
*   **`SummarizationTier`**: Enum defining types of content generation (e.g., Key Takeaways, Quick Summary, Detailed Explanation, Story).

### 1.2. Firebase Models (primarily in `FirebaseModels.swift`)

These structures are Codable and map directly to the data stored in Firestore.

*   **`FirebaseStory`**: Firestore representation of a story.
    *   `id`: `String?` (@DocumentID)
    *   `userId`: `String?`
    *   `title`: `String?`
    *   `overview`: `String?` (Mapped from local `Story.content`)
    *   `level`: `String?`
    *   `imageStyle`: `String?`
    *   `chapters`: `[FirebaseChapter]?`
    *   `createdAt`: `Timestamp?` (@ServerTimestamp)

*   **`FirebaseChapter`**: Firestore representation of a story chapter.
    *   `id`: `String` (derived from `chapterId` or a new UUID)
    *   `chapterId`: `String?` (The intended unique ID for the chapter)
    *   `title`: `String?`
    *   `content`: `String?`
    *   `order`: `Int?`
    *   `firebaseImageUrl`: `String?` (URL from Firebase Storage)
    *   `imageStyle`: `String?`

*   **`FirebaseUserContent`**: Firestore representation for general user-generated content.
    *   `id`: `String?` (@DocumentID)
    *   `userId`: `String?`
    *   `topic`: `String?`
    *   `level`: `String?`
    *   `summarizationTier`: `String?`
    *   `blocks`: `[FirebaseContentBlock]?`
    *   `createdAt`: `Timestamp?` (@ServerTimestamp)

*   **`FirebaseContentBlock`**: Firestore representation of a content block.
    *   `id`: `String` (UUID().uuidString, not a @DocumentID as it's part of an array)
    *   `type`: `String?`
    *   `content`: `String?`
    *   `alt`: `String?`
    *   `firebaseImageUrl`: `String?`
    *   `options`: `[FirebaseQuizOption]?`
    *   `correctAnswerID`: `String?`
    *   `explanation`: `String?`
    *   `originalUrl`: `String?` (Fallback or source URL for an image)

*   **`FirebaseQuizOption`**: Firestore representation of a quiz option.
    *   `id`: `String?`
    *   `text`: `String?`

### 1.3. Model Mapping

*   `FirebaseTestViewModel.swift` contains helper functions to convert between Firebase models and local app models:
    *   `convertFirebaseStoryToAppStory(_:)`: Maps `FirebaseStory` to `Story`.
    *   `convertFirebaseUserContentToAppData(_:)`: Maps `FirebaseUserContent` to a tuple containing `topic`, `[ContentBlock]`, `ReadingLevel`, and `SummarizationTier`.
*   When saving data, local models are transformed into dictionaries that match the structure of Firebase models before being written to Firestore.

## 2. Data Storage and Retrieval in Firebase

Firebase is used as the primary cloud persistence layer, utilizing Firestore Database and Firebase Storage.

### 2.1. Firestore Database Structure

*   **`users` collection**:
    *   Stores user profile information.
    *   Document ID: `userId` (Firebase Auth UID).
    *   Fields: `name`, `email`, `isStudent`, `studentLevel`, `topicsOfInterest`, `preferredReadingLevel`, `preferredFontStyle`, `profileImageURL`, `selectedAvatar`, `createdAt`.
    *   Managed by: `AuthViewModel.swift`.

*   **`stories` collection**:
    *   Stores user-generated stories.
    *   Document ID: `story.id.uuidString` (from the local `Story` object's ID).
    *   Each document is structured like `FirebaseStory`.
    *   Managed by: `ContentView.swift` (for saving) and `FirebaseTestViewModel.swift` (for fetching).

*   **`userGeneratedContent` collection**:
    *   Stores other forms of generated content like summaries, explanations, and their associated quizzes, structured as blocks.
    *   Document ID: A newly generated `UUID().uuidString`.
    *   Each document is structured like `FirebaseUserContent`.
    *   Managed by: `ContentView.swift` (for saving) and `FirebaseTestViewModel.swift` (for fetching).

### 2.2. Firebase Storage

Used for storing image files.

*   **Story Chapter Images**:
    *   Path: `stories/<userId>/<storyId>/<chapterId>.jpg`
    *   Example: `stories/user123/storyABC/chapterXYZ.jpg`
    *   The downloadable URL for each image is stored in the `firebaseImageUrl` field of the corresponding `FirebaseChapter` object within a `FirebaseStory` document in Firestore.

*   **User Content Block Images**:
    *   Path: `userGeneratedContent/<userId>/<contentDocumentId>/<imageId>.jpg`
    *   Example: `userGeneratedContent/user123/contentDoc456/image789.jpg`
    *   The downloadable URL is stored in the `firebaseImageUrl` (or `originalUrl` as a fallback) field of the corresponding `FirebaseContentBlock` object within a `FirebaseUserContent` document.

### 2.3. Data Saving Process

Data is generally saved to Firebase after content generation or user profile updates.

*   **Stories (`ContentView.saveStoryToFirebase`)**:
    1.  Takes a local `Story` object and `userId`.
    2.  Iterates through `story.chapters`.
    3.  For each chapter with an associated `UIImage` (usually generated and held in `ContentView.storyImages`):
        *   Converts `UIImage` to JPEG `Data`.
        *   Uploads the image data to Firebase Storage at the designated path.
        *   Retrieves the download URL.
    4.  Constructs a dictionary matching the `FirebaseStory` structure, embedding chapter data (including `firebaseImageUrl`s) as an array of dictionaries.
    5.  Uses `db.collection("stories").document(story.id.uuidString).setData()` to save the story to Firestore. `FieldValue.serverTimestamp()` is used for `createdAt`.

*   **User Content (`ContentView.saveContentBlocksToFirebase`)**:
    1.  Takes `topic`, `[ContentBlock]`, `level`, `summarizationTier`, and `userId`.
    2.  Generates a unique `contentDocumentId` for the Firestore document.
    3.  Iterates through the local `ContentBlock` array.
    4.  For image blocks with a `localImagePath` (image data loaded locally):
        *   Generates a unique `imageFileName`.
        *   Uploads image data to Firebase Storage at the designated path.
        *   Retrieves the download URL.
    5.  Constructs an array of dictionaries, each matching the `FirebaseContentBlock` structure (including `firebaseImageUrl` or `originalUrl` for images).
    6.  Constructs a main dictionary matching `FirebaseUserContent`.
    7.  Uses `db.collection("userGeneratedContent").document(contentDocumentId).setData()` to save to Firestore.

*   **User Profile Data (`AuthViewModel.saveUserDataToFirestore`, `AuthViewModel.updateUserField`)**:
    *   `saveUserDataToFirestore`: Called during signup. Creates a new document in the `users` collection with the `userId` as the document ID.
    *   `updateUserField`: Updates specific fields in an existing user document using `updateData()`.

### 2.4. Data Retrieval Process

Data is fetched primarily to display user history or sync profile information.

*   **Stories and User Content (`FirebaseTestViewModel.swift`)**:
    *   `fetchStories()`: Retrieves documents from the "stories" collection, ordered by `createdAt`.
    *   `fetchUserContent()`: Retrieves documents from the "userGeneratedContent" collection, ordered by `createdAt`.
    *   Both methods use `document.data(as: ModelType.self)` to decode Firestore documents directly into the respective Firebase model types (`FirebaseStory`, `FirebaseUserContent`).
    *   The fetched Firebase models are then converted to local app models using `convertFirebaseStoryToAppStory` and `convertFirebaseUserContentToAppData` for use in the UI.

*   **User Profile Data (`AuthViewModel.fetchUserData`)**:
    *   Retrieves a specific user's document from the "users" collection using their `userId`.
    *   Populates the `AuthViewModel`'s `@Published` properties with the fetched data.

## 3. Content and Story Generation Process (Frontend Perspective)

The app interacts with a backend service (presumably `https://backend-orasync-test.onrender.com`) to generate content.

1.  **User Input**:
    *   The user provides text via `inputText` in `ContentView`.
    *   Selects `ReadingLevel`, `SummarizationTier`.
    *   If `SummarizationTier == .story`, also selects `selectedGenre`, `mainCharacter` (optional), and `selectedImageStyle`.

2.  **API Request (`ContentView.generateContent`)**:
    *   The function determines the backend endpoint and request body based on `selectedSummarizationTier`.
    *   **For Stories**:
        *   Endpoint: `/generate_story`.
        *   A detailed `storyPrompt` is constructed, including the original text, level, genre, character info, and image style hint.
        *   Request body includes: `text` (the prompt), `level`, `genre`, `image_style`.
    *   **For Other Content (e.g., Summaries)**:
        *   Endpoint: (e.g., `/summarize`, `/generate_blocks` - specific endpoint not fully detailed but implied).
        *   Request body typically includes `text` (input) and `level`.
    *   A `URLRequest` is made to the backend.

3.  **Response Handling**:
    *   The backend's JSON response is decoded into a `Response` struct (defined in `Models.swift`). This struct can contain:
        *   `story: Story?`
        *   `blocks: [ContentBlock]?`
        *   `error: String?`
    *   If `result.story` is present (for story generation):
        *   `ContentView.currentStory` is updated.
        *   The story is saved to local history (SwiftData).
        *   A task is launched to:
            1.  Call `generateImagesForStory()` (see below).
            2.  Call `saveStoryToFirebase()` (uploads story text and chapter image URLs).
    *   If `result.blocks` is present (for other content):
        *   `ContentView.blocks` is updated.
        *   Images within blocks (if `block.type == .image` and `block.url` is present) are downloaded and saved locally by `ImageDownloader.shared.downloadAndSaveImage`, and `block.localImagePath` is updated.
        *   Content is saved to local history.
        *   `saveContentBlocksToFirebase()` is called (uploads block content and any locally processed image URLs).

4.  **Image Generation for Stories (`ContentView.generateImagesForStory` & `fetchImageForChapter`)**:
    *   `generateImagesForStory(_ story: Story)` iterates through each `StoryChapter`.
    *   For each chapter, it calls `fetchImageForChapter(chapter: StoryChapter, maxSize: CGSize)`.
    *   `fetchImageForChapter` is presumed to make another backend API call (e.g., to a `/generate_image_for_chapter` endpoint), likely sending chapter content and the `imageStyle`.
    *   The backend returns an image, which is converted to `UIImage`.
    *   These `UIImage`s are temporarily stored in `ContentView.storyImages: [String: UIImage]` (keyed by chapter ID).
    *   These images are then used by `saveStoryToFirebase` for uploading to Firebase Storage.

## 4. Stitching Data Together for Display

Once data is generated or fetched, it's displayed in the UI.

### 4.1. Story Display

*   When `ContentView.currentStory` (a `Story` object) is populated:
    *   `ContentView` might display a `StoryView` (a subview defined in `ContentView.swift`) or transition to `StoryFullScreenView` (from `ReadingViews.swift`).
    *   `StoryView`/`StoryFullScreenView` takes the `Story` object.
    *   It typically displays `story.title`.
    *   It iterates through `story.chapters` (usually sorted by `chapter.order`) to display each `chapter.title` and `chapter.content`.
    *   Chapter images are loaded using the `chapter.imageUrl` (which points to Firebase Storage) or `chapter.localImagePath` (if available and relevant).

### 4.2. Content Block Display

*   When `ContentView.blocks` (an array of `ContentBlock`) is populated:
    *   `ContentView.currentContentDisplayView()` is responsible for rendering these blocks.
    *   It iterates through the `blocks` array.
    *   For each `ContentBlock`, it uses the `block.type` to determine how to render it.
    *   Specific views for each block type (e.g., `ParagraphView`, `ImageView`, `MultipleChoiceQuizView`) are likely defined in `ContentBlockViews.swift`.
        *   `.heading`: Displays `block.content` as a heading.
        *   `.paragraph`: Displays `block.content` as a paragraph.
        *   `.image`: Displays an image using `block.url` (external), `block.firebaseImageUrl` (from Firebase), or `block.localImagePath` (local cache). `block.alt` is used for accessibility.
        *   `.multipleChoiceQuestion`: Displays `block.content` (question), `block.options` (choices), and handles answer selection, checking against `block.correctAnswerID`, and showing `block.explanation`.

### 4.3. Detailed Content Generation Analysis

#### 4.3.1. Frontend Option Selection UI

The UI for content generation is structured in multiple layers:

a) **Basic Input Options**:
- Text input field for the main content/topic
- Reading level selection (Kid, PreTeen, Teen, University, Standard)
- Summarization tier selection (determines the type of content to generate)

b) **Story-Specific Options** (shown only when story generation is selected):
- Genre Picker (Adventure, Fantasy, Mystery, Science Fiction, Historical, Educational)
- Main Character Input (optional)
- Image Style Selection (e.g., Ghibli style)

#### 4.3.2. Content Generation Process

The generation process follows these steps:

a) **Pre-Generation Checks**:
- Validates remaining generations (limit of 5)
- Checks input text is not empty
- Verifies input length is within limits (5000 characters)
- Clears previous content and error messages

b) **Request Preparation**:
```swift
// For Story Generation
let storyPrompt = """
[Level: \(selectedLevel.rawValue)]
Please convert the following text into an engaging \(selectedGenre.lowercased()) story, maintaining the key information but presenting it in a narrative format.
Image Style to consider for tone and visuals: \(selectedImageStyle.displayName).
\(characterContext)
Original Text:
\(inputText)
"""

// Request Body
requestBody = [
    "text": storyPrompt,
    "level": selectedLevel.rawValue,
    "genre": selectedGenre.lowercased(),
    "image_style": selectedImageStyle.backendRawValue
]
```

#### 4.3.3. API Call and Response Handling

a) **Story Generation**:
```swift
// Endpoint: /generate_story
if let story = result.story {
    // Update UI state
    currentStory = story
    blocks = []
    isShowingFullScreenStory = true
    
    // Generate images and save to Firebase
    Task {
        await generateImagesForStory(story)
        if let currentUser = Auth.auth().currentUser {
            await saveStoryToFirebase(story: story, userId: currentUser.uid)
        }
    }
}
```

b) **Regular Content Generation**:
```swift
if let blocksFromResponse = result.blocks {
    // Update UI
    blocks = blocksFromResponse
    
    // Save to Firebase if user is authenticated
    if let currentUser = Auth.auth().currentUser {
        await saveContentBlocksToFirebase(
            topic: extractTopicTitle(from: inputText),
            blocks: blocksFromResponse,
            level: selectedLevel,
            summarizationTier: selectedSummarizationTier,
            userId: currentUser.uid
        )
    }
}
```

#### 4.3.4. Image Generation for Stories

```swift
private func generateImagesForStory(_ story: Story) async {
    let imageSize = CGSize(width: 800, height: 600)
    
    for chapter in story.chapters {
        if let image = await fetchImageForChapter(chapter: chapter, maxSize: imageSize) {
            // Upload image directly to Firebase Storage
            if let imageData = image.jpegData(compressionQuality: 0.8) {
                let storageRef = Storage.storage().reference()
                let imagePath = "stories/\(userId)/\(story.id.uuidString)/\(chapter.id.uuidString).jpg"
                let imageRef = storageRef.child(imagePath)
                
                do {
                    let _ = try await imageRef.putDataAsync(imageData)
                    let downloadURL = try await imageRef.downloadURL()
                    
                    // Update chapter with Firebase image URL
                    chapter.firebaseImageUrl = downloadURL.absoluteString
                } catch {
                    print("Error uploading image: \(error)")
                }
            }
        }
    }
}
```

#### 4.3.5. Data Persistence

The generated content is saved exclusively in Firebase:

a) **Firebase**:
- Stories collection: Stores story text and chapter image URLs
- UserGeneratedContent collection: Stores content blocks and associated images
- Images are stored in Firebase Storage with organized paths

#### 4.3.6. UI Updates and Display

The UI updates based on the generation type:

a) **Story Display**:
```swift
StoryView(story: story)
    - Shows story title
    - Displays chapters in order
    - Each chapter shows title and content
    - Images are displayed if available
```

b) **Content Block Display**:
```swift
currentContentDisplayView()
    - Renders different block types (heading, paragraph, image, quiz)
    - Handles interactive elements like quizzes
    - Manages image loading and display
```

#### 4.3.7. Error Handling and Loading States

- Shows loading indicator during generation
- Displays error messages if generation fails
- Handles network errors and server responses
- Manages generation limits and input validation

This comprehensive system allows for flexible content generation with different styles and formats, while maintaining a consistent user experience and proper data persistence. The architecture supports both story generation with images and regular content generation with various block types, all while handling authentication, data persistence, and proper error states.

## 5. Simplified Data Flow Summary

1.  **Input**: User provides text/topic and selects generation parameters (level, type, genre, etc.) in UI (`ContentView`).
2.  **Generation Request**: App sends a formatted request to the backend API.
3.  **Backend Processing**: Backend generates story/content and potentially images. (Details outside this document's scope).
4.  **Generation Response**: Backend returns structured data (JSON for story object or content blocks).
5.  **App Processing**:
    *   App decodes the response into local models (`Story` or `[ContentBlock]`).
    *   For stories, it may trigger further backend calls for chapter images.
    *   Generated images (or their data) are temporarily stored.
6.  **Display**:
    *   The processed local models (`currentStory` or `blocks`) are used to update the UI via SwiftUI views (`StoryView`, `ContentBlockViews`).
7.  **Persistence (Async)**:
    *   Data (story/content text, image URLs) is saved to **Firestore**.
    *   Images are uploaded to **Firebase Storage**.
    *   Data is saved to local **SwiftData history**.
8.  **Retrieval (for History/Sync)**:
    *   App fetches data from Firestore (`FirebaseTestViewModel`).
    *   Firebase models are converted to local app models.
    *   Data is displayed in history views or used to sync user state.

This covers the primary aspects of data architecture, Firebase integration, content generation flow, and data presentation within the ReadBuddy application from a frontend perspective.
